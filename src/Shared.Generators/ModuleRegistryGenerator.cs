using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Shared.Infrastructure.Generators;

/// <summary>
/// Source generator that discovers all IModuleStartup implementations in referenced assemblies
/// and generates a static ModuleRegistry class.
/// </summary>
/// <remarks>
/// Dependencies:
/// - Requires Shared.Abstractions package with IModuleStartup interface
/// - If IModuleStartup is renamed/moved, update <see cref="ModuleTypeNames"/> constants
/// </remarks>
[Generator(LanguageNames.CSharp)]
public class ModuleRegistryGenerator : IIncrementalGenerator
{
    /// <summary>
    /// Type name constants. Update these if IModuleStartup is renamed or moved.
    /// </summary>
    private static class ModuleTypeNames
    {
        /// <summary>
        /// Full name of IModuleStartup interface from Shared.Infrastructure.
        /// </summary>
        public const string IModuleStartup = "Shared.Infrastructure.Modules.IModuleStartup";
        
        /// <summary>
        /// Full name of the marker attribute (generated by this generator).
        /// </summary>
        public const string ModuleRegistryAttribute = "Shared.Abstractions.Generators.ModuleRegistryAttribute";
    }

    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find classes marked with [GenerateModuleRegistry]
        var classDeclarations = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                ModuleTypeNames.ModuleRegistryAttribute,
                predicate: static (node, _) => node is ClassDeclarationSyntax,
                transform: static (ctx, _) => GetGenerationInfo(ctx))
            .Where(static info => info is not null);

        // Combine with compilation to get all IModuleStartup types
        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

        // Generate the source
        context.RegisterSourceOutput(compilationAndClasses, static (spc, source) =>
        {
            var (compilation, generationInfos) = source;
            
            foreach (var info in generationInfos)
            {
                if (info is null) continue;
                
                var modules = FindModuleImplementations(compilation);
                var sourceCode = GenerateModuleRegistry(info.Value.Namespace, modules);
                spc.AddSource("ModuleRegistry.g.cs", sourceCode);
            }
        });
    }

    private static GenerationInfo? GetGenerationInfo(GeneratorAttributeSyntaxContext context)
    {
        var classSymbol = context.TargetSymbol as INamedTypeSymbol;
        if (classSymbol is null) return null;

        var attributeData = context.Attributes.FirstOrDefault(a =>
            a.AttributeClass?.ToDisplayString() == ModuleTypeNames.ModuleRegistryAttribute);

        string? customNamespace = null;
        if (attributeData?.NamedArguments.FirstOrDefault(a => a.Key == "Namespace").Value.Value is string ns)
        {
            customNamespace = ns;
        }

        // Get namespace, handling global namespace case
        var targetNamespace = customNamespace;
        if (string.IsNullOrEmpty(targetNamespace))
        {
            var containingNamespace = classSymbol.ContainingNamespace;
            if (containingNamespace != null && !containingNamespace.IsGlobalNamespace)
            {
                targetNamespace = containingNamespace.ToDisplayString();
            }
        }

        return new GenerationInfo(targetNamespace);
    }

    private static ImmutableArray<ModuleInfo> FindModuleImplementations(Compilation compilation)
    {
        var iModuleSymbol = compilation.GetTypeByMetadataName(ModuleTypeNames.IModuleStartup);
        if (iModuleSymbol is null)
        {
            // IModuleStartup not found - this means Shared.Abstractions is not referenced
            // Return empty array; modules won't be discovered but compilation will succeed
            return ImmutableArray<ModuleInfo>.Empty;
        }

        var modules = new List<ModuleInfo>();

        // Scan all referenced assemblies
        foreach (var reference in compilation.References)
        {
            if (compilation.GetAssemblyOrModuleSymbol(reference) is not IAssemblySymbol assemblySymbol)
                continue;

            // Skip system assemblies
            var assemblyName = assemblySymbol.Name;
            if (IsSystemAssembly(assemblyName))
                continue;

            FindModulesInNamespace(assemblySymbol.GlobalNamespace, iModuleSymbol, modules);
        }

        // Also scan the current compilation
        FindModulesInNamespace(compilation.Assembly.GlobalNamespace, iModuleSymbol, modules);

        return modules
            .OrderBy(m => m.TypeName)
            .ToImmutableArray();
    }

    private static void FindModulesInNamespace(
        INamespaceSymbol namespaceSymbol,
        INamedTypeSymbol iModuleSymbol,
        List<ModuleInfo> modules)
    {
        foreach (var type in namespaceSymbol.GetTypeMembers())
        {
            if (IsModuleImplementation(type, iModuleSymbol))
            {
                modules.Add(new ModuleInfo(type.ToDisplayString()));
            }
        }

        foreach (var nestedNamespace in namespaceSymbol.GetNamespaceMembers())
        {
            FindModulesInNamespace(nestedNamespace, iModuleSymbol, modules);
        }
    }

    private static bool IsModuleImplementation(INamedTypeSymbol type, INamedTypeSymbol iModuleSymbol)
    {
        // Must be a concrete class
        if (type.IsAbstract || type.TypeKind != TypeKind.Class)
            return false;

        // Must have parameterless constructor
        if (!type.Constructors.Any(c => c.Parameters.IsEmpty && c.DeclaredAccessibility == Accessibility.Public))
            return false;

        // Must implement IModuleStartup
        return type.AllInterfaces.Any(i => SymbolEqualityComparer.Default.Equals(i, iModuleSymbol));
    }

    private static bool IsSystemAssembly(string assemblyName)
    {
        return assemblyName.StartsWith("System", StringComparison.OrdinalIgnoreCase)
            || assemblyName.StartsWith("Microsoft", StringComparison.OrdinalIgnoreCase)
            || assemblyName.StartsWith("netstandard", StringComparison.OrdinalIgnoreCase)
            || assemblyName.StartsWith("mscorlib", StringComparison.OrdinalIgnoreCase)
            || assemblyName.StartsWith("Npgsql", StringComparison.OrdinalIgnoreCase)
            || assemblyName.StartsWith("Newtonsoft", StringComparison.OrdinalIgnoreCase)
            || assemblyName.StartsWith("Serilog", StringComparison.OrdinalIgnoreCase)
            || assemblyName.StartsWith("MediatR", StringComparison.OrdinalIgnoreCase)
            || assemblyName.StartsWith("FluentValidation", StringComparison.OrdinalIgnoreCase);
    }

    private static string GenerateModuleRegistry(string? targetNamespace, ImmutableArray<ModuleInfo> modules)
    {
        var sb = new StringBuilder();
        var indent = string.IsNullOrEmpty(targetNamespace) ? "" : "    ";

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Microsoft.AspNetCore.Builder;");
        sb.AppendLine("using Microsoft.Extensions.Configuration;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine("using Microsoft.Extensions.Logging;");
        sb.AppendLine("using Shared.Abstractions.Modules;");
        sb.AppendLine("using Shared.Infrastructure.Modules;");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(targetNamespace))
        {
            sb.AppendLine($"namespace {targetNamespace}");
            sb.AppendLine("{");
        }

        sb.AppendLine($"{indent}/// <summary>");
        sb.AppendLine($"{indent}/// Auto-generated module registry. Contains all discovered IModuleStartup implementations.");
        sb.AppendLine($"{indent}/// </summary>");
        sb.AppendLine($"{indent}public static class ModuleRegistry");
        sb.AppendLine($"{indent}{{");

        // RegisterModules extension method
        sb.AppendLine($"{indent}    /// <summary>");
        sb.AppendLine($"{indent}    /// Registers all modules by calling their Register() method.");
        sb.AppendLine($"{indent}    /// Each module is responsible for registering its own services.");
        sb.AppendLine($"{indent}    /// </summary>");
        sb.AppendLine($"{indent}    /// <remarks>");
        sb.AppendLine($"{indent}    /// All module instances are registered as singletons in DI.");
        sb.AppendLine($"{indent}    /// To access all modules, resolve IEnumerable&lt;IModuleStartup&gt; from the service provider:");
        sb.AppendLine($"{indent}    /// </remarks>");
        sb.AppendLine($"{indent}    /// <param name=\"services\">The service collection.</param>");
        sb.AppendLine($"{indent}    /// <param name=\"configuration\">The application configuration.</param>");
        sb.AppendLine($"{indent}    /// <returns>The service collection for chaining.</returns>");
        sb.AppendLine($"{indent}    public static IServiceCollection RegisterModules(");
        sb.AppendLine($"{indent}        this IServiceCollection services,");
        sb.AppendLine($"{indent}        IConfiguration configuration)");
        sb.AppendLine($"{indent}    {{");
        sb.AppendLine($"{indent}        IModuleStartup[] modules =");
        sb.AppendLine($"{indent}        [");
        foreach (var module in modules)
        {
            sb.AppendLine($"{indent}            new {module.TypeName}(),");
        }
        sb.AppendLine($"{indent}        ];");
        sb.AppendLine();
        sb.AppendLine($"{indent}        foreach (var module in modules)");
        sb.AppendLine($"{indent}        {{");
        sb.AppendLine($"{indent}            module.Register(services, configuration);");
        sb.AppendLine($"{indent}            services.AddSingleton<IModuleStartup>(module);");
        sb.AppendLine($"{indent}        }}");
        sb.AppendLine();
        sb.AppendLine($"{indent}        return services;");
        sb.AppendLine($"{indent}    }}");
        sb.AppendLine();

        // UseModules extension method
        sb.AppendLine($"{indent}    /// <summary>");
        sb.AppendLine($"{indent}    /// Configures middleware for all modules by calling their Use() method.");
        sb.AppendLine($"{indent}    /// Each module is responsible for configuring its own middleware and endpoints.");
        sb.AppendLine($"{indent}    /// </summary>");
        sb.AppendLine($"{indent}    /// <param name=\"app\">The application builder.</param>");
        sb.AppendLine($"{indent}    /// <param name=\"configuration\">The application configuration.</param>");
        sb.AppendLine($"{indent}    /// <returns>The application builder for chaining.</returns>");
        sb.AppendLine($"{indent}    public static IApplicationBuilder UseModules(");
        sb.AppendLine($"{indent}        this IApplicationBuilder app,");
        sb.AppendLine($"{indent}        IConfiguration configuration)");
        sb.AppendLine($"{indent}    {{");
        sb.AppendLine($"{indent}        var modules = app.ApplicationServices.GetServices<IModuleStartup>();");
        sb.AppendLine($"{indent}        var logger = app.ApplicationServices.GetRequiredService<ILogger<IModuleStartup>>();");
        sb.AppendLine();
        sb.AppendLine($"{indent}        foreach (var module in modules)");
        sb.AppendLine($"{indent}        {{");
        sb.AppendLine($"{indent}            try");
        sb.AppendLine($"{indent}            {{");
        sb.AppendLine($"{indent}                logger.LogInformation(\"Configuring module '{{ModuleName}}'...\", module.Id);");
        sb.AppendLine($"{indent}                module.Use(app, configuration);");
        sb.AppendLine($"{indent}            }}");
        sb.AppendLine($"{indent}            catch (Exception ex)");
        sb.AppendLine($"{indent}            {{");
        sb.AppendLine($"{indent}                logger.LogError(ex, \"Error configuring module '{{ModuleName}}'\", module.Id);");
        sb.AppendLine($"{indent}                throw;");
        sb.AppendLine($"{indent}            }}");
        sb.AppendLine($"{indent}        }}");
        sb.AppendLine();
        sb.AppendLine($"{indent}        return app;");
        sb.AppendLine($"{indent}    }}");
        sb.AppendLine();

        // InitModules extension method
        sb.AppendLine($"{indent}    /// <summary>");
        sb.AppendLine($"{indent}    /// Initializes all modules by calling their Initialize() method.");
        sb.AppendLine($"{indent}    /// Each module is responsible for its own initialization tasks (migrations, seeding, etc).");
        sb.AppendLine($"{indent}    /// </summary>");
        sb.AppendLine($"{indent}    /// <param name=\"serviceProvider\">The service provider.</param>");
        sb.AppendLine($"{indent}    /// <param name=\"cancellationToken\">The cancellation token.</param>");
        sb.AppendLine($"{indent}    /// <returns>A task representing the asynchronous initialization operation.</returns>");
        sb.AppendLine($"{indent}    public static async Task InitModules(");
        sb.AppendLine($"{indent}        this IServiceProvider serviceProvider,");
        sb.AppendLine($"{indent}        CancellationToken cancellationToken = default)");
        sb.AppendLine($"{indent}    {{");
        sb.AppendLine($"{indent}        var modules = serviceProvider.GetServices<IModuleStartup>();");
        sb.AppendLine($"{indent}        var logger = serviceProvider.GetRequiredService<ILogger<IModuleStartup>>();");
        sb.AppendLine();
        sb.AppendLine($"{indent}        foreach (var module in modules)");
        sb.AppendLine($"{indent}        {{");
        sb.AppendLine($"{indent}            try");
        sb.AppendLine($"{indent}            {{");
        sb.AppendLine($"{indent}                logger.LogInformation(\"Initializing module '{{ModuleName}}'...\", module.Id);");
        sb.AppendLine($"{indent}                await module.Initialize(serviceProvider, cancellationToken);");
        sb.AppendLine($"{indent}            }}");
        sb.AppendLine($"{indent}            catch (Exception ex)");
        sb.AppendLine($"{indent}            {{");
        sb.AppendLine($"{indent}                logger.LogError(ex, \"Error initializing module '{{ModuleName}}'\", module.Id);");
        sb.AppendLine($"{indent}                throw;");
        sb.AppendLine($"{indent}            }}");
        sb.AppendLine($"{indent}        }}");
        sb.AppendLine($"{indent}    }}");

        sb.AppendLine($"{indent}}}");

        if (!string.IsNullOrEmpty(targetNamespace))
        {
            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    private readonly struct GenerationInfo
    {
        public GenerationInfo(string? ns) => Namespace = ns;
        public string? Namespace { get; }
    }

    private readonly struct ModuleInfo
    {
        public ModuleInfo(string typeName) => TypeName = typeName;
        public string TypeName { get; }
    }
}

