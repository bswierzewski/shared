#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

using System.Reflection;
using System.Text;
using Shared.Abstractions.Options;

namespace Shared.EnvFileGenerator.Services;

/// <summary>
/// Generates .env file content from IOptions types.
/// </summary>
internal class EnvContentGenerator
{
    private readonly PropertyValueFormatter _formatter;

    public EnvContentGenerator(PropertyValueFormatter formatter)
    {
        _formatter = formatter;
    }

    /// <summary>
    /// Generates .env content from a list of options types.
    /// </summary>
    public string Generate(List<Type> optionsTypes, bool includeDescriptions)
    {
        var sb = new StringBuilder();
        sb.AppendLine("# Environment Variables Configuration");
        sb.AppendLine("# Generated by Shared.EnvFileGenerator");
        sb.AppendLine();

        var uniqueTypes = DeduplicateTypes(optionsTypes);

        foreach (var type in uniqueTypes)
        {
            var sectionName = GetSectionName(type);

            sb.AppendLine("# ==========================================");
            sb.AppendLine($"# {sectionName}");
            sb.AppendLine("# ==========================================");

            var rootInstance = _formatter.CreateInstance(type);
            GeneratePropertiesRecursive(rootInstance, type, sectionName, "",
                _formatter.GetPublicProperties(type), includeDescriptions, sb);
        }
        return sb.ToString();
    }

    /// <summary>
    /// Lists all available configuration sections with their properties.
    /// </summary>
    public void ListSections(List<Type> optionsTypes, bool verbose)
    {
        Console.WriteLine($"\nFound {optionsTypes.Count} configuration section(s):\n");

        var uniqueTypes = DeduplicateTypes(optionsTypes);

        foreach (var type in uniqueTypes)
        {
            var sectionName = GetSectionName(type);
            var properties = _formatter.GetPublicProperties(type);

            Console.WriteLine($"[{sectionName}]");
            if (verbose)
            {
                ListPropertiesRecursive(type, sectionName, "", properties);
                Console.WriteLine();
            }
            else
            {
                Console.WriteLine($"  Properties: {properties.Count}\n");
            }
        }
    }

    private void GeneratePropertiesRecursive(object? currentInstance, Type currentType, string sectionName,
        string nestedPath, List<PropertyInfo> properties, bool includeDescriptions, StringBuilder sb)
    {
        foreach (var property in properties)
        {
            if (property.PropertyType.GetInterfaces().Any(i => i == typeof(IOptions)))
                continue;

            if (_formatter.IsSimpleType(property.PropertyType))
            {
                var envName = GetEnvVariableName(sectionName, property, nestedPath);
                var defaultValue = _formatter.GetPropertyDefaultValue(currentInstance, property);

                if (includeDescriptions)
                    sb.AppendLine($"# Type: {_formatter.GetTypeName(property.PropertyType)}");

                sb.AppendLine($"{envName}={defaultValue}");
                sb.AppendLine();
            }
            else if (_formatter.IsComplexType(property.PropertyType))
            {
                var nestedProperties = _formatter.GetPublicProperties(property.PropertyType);
                if (nestedProperties.Count > 0)
                {
                    var newNestedPath = string.IsNullOrEmpty(nestedPath)
                        ? property.Name
                        : $"{nestedPath}_{property.Name}";

                    var nestedInstance = currentInstance != null
                        ? property.GetValue(currentInstance)
                        : _formatter.CreateInstance(property.PropertyType);

                    GeneratePropertiesRecursive(nestedInstance, property.PropertyType, sectionName, newNestedPath,
                        nestedProperties, includeDescriptions, sb);
                }
            }
        }
    }

    private void ListPropertiesRecursive(Type rootType, string sectionName, string nestedPath,
        List<PropertyInfo> properties)
    {
        foreach (var property in properties)
        {
            if (property.PropertyType.GetInterfaces().Any(i => i == typeof(IOptions)))
                continue;

            if (_formatter.IsSimpleType(property.PropertyType))
            {
                var envName = GetEnvVariableName(sectionName, property, nestedPath);
                Console.WriteLine($"  {envName} ({_formatter.GetTypeName(property.PropertyType)})");
            }
            else if (_formatter.IsComplexType(property.PropertyType))
            {
                var nestedProperties = _formatter.GetPublicProperties(property.PropertyType);
                if (nestedProperties.Count > 0)
                {
                    var newNestedPath = string.IsNullOrEmpty(nestedPath)
                        ? property.Name
                        : $"{nestedPath}_{property.Name}";

                    ListPropertiesRecursive(rootType, sectionName, newNestedPath, nestedProperties);
                }
            }
        }
    }

    private List<Type> DeduplicateTypes(List<Type> types)
        => types.GroupBy(t => t.FullName).Select(g => g.First()).OrderBy(t => GetSectionName(t)).ToList();

    private string GetSectionName(Type type)
    {
        var prop = type.GetProperty("SectionName", BindingFlags.Public | BindingFlags.Static);
        return prop?.GetValue(null)?.ToString() ?? type.Name.Replace("Options", "");
    }

    private string GetEnvVariableName(string section, PropertyInfo prop, string nestedPath = "")
    {
        var baseName = $"{section.ToUpperInvariant().Replace(":", "__")}";
        if (!string.IsNullOrEmpty(nestedPath))
        {
            var nestedPathUpper = nestedPath.ToUpperInvariant().Replace("_", "__");
            baseName += $"__{nestedPathUpper}";
        }
        baseName += $"__{prop.Name.ToUpperInvariant()}";
        return baseName;
    }
}
