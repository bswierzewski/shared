using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Shared.Infrastructure.Generators;

/// <summary>
/// Source generator that discovers all IModule implementations in referenced assemblies
/// and generates a static ModuleRegistry class.
/// </summary>
/// <remarks>
/// Dependencies:
/// - Requires Shared.Abstractions package with IModule interface
/// - If IModule is renamed/moved, update <see cref="ModuleTypeNames"/> constants
/// </remarks>
[Generator(LanguageNames.CSharp)]
public class ModuleRegistryGenerator : IIncrementalGenerator
{
    /// <summary>
    /// Type name constants. Update these if IModule is renamed or moved.
    /// </summary>
    private static class ModuleTypeNames
    {
        /// <summary>
        /// Full name of IModule interface from Shared.Abstractions.
        /// </summary>
        public const string IModule = "Shared.Abstractions.Modules.IModule";
        
        /// <summary>
        /// Full name of the marker attribute (generated by this generator).
        /// </summary>
        public const string GenerateModuleRegistryAttribute = "Shared.Abstractions.Modules.GenerateModuleRegistryAttribute";
    }

    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register attribute for syntax highlighting
        context.RegisterPostInitializationOutput(ctx =>
        {
            ctx.AddSource("GenerateModuleRegistryAttribute.g.cs", """
                // <auto-generated/>
                #nullable enable
                
                namespace Shared.Abstractions.Modules;
                
                /// <summary>
                /// Marks a class (typically Program) to trigger module registry generation.
                /// The generator will discover all IModule implementations in referenced assemblies.
                /// </summary>
                [System.AttributeUsage(System.AttributeTargets.Class, AllowMultiple = false)]
                public sealed class GenerateModuleRegistryAttribute : System.Attribute
                {
                    /// <summary>
                    /// Optional namespace for the generated ModuleRegistry class.
                    /// If not specified, uses the namespace of the marked class.
                    /// </summary>
                    public string? Namespace { get; set; }
                }
                """);
        });

        // Find classes marked with [GenerateModuleRegistry]
        var classDeclarations = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                ModuleTypeNames.GenerateModuleRegistryAttribute,
                predicate: static (node, _) => node is ClassDeclarationSyntax,
                transform: static (ctx, _) => GetGenerationInfo(ctx))
            .Where(static info => info is not null);

        // Combine with compilation to get all IModule types
        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

        // Generate the source
        context.RegisterSourceOutput(compilationAndClasses, static (spc, source) =>
        {
            var (compilation, generationInfos) = source;
            
            foreach (var info in generationInfos)
            {
                if (info is null) continue;
                
                var modules = FindModuleImplementations(compilation);
                var sourceCode = GenerateModuleRegistry(info.Value.Namespace, modules);
                spc.AddSource("ModuleRegistry.g.cs", sourceCode);
            }
        });
    }

    private static GenerationInfo? GetGenerationInfo(GeneratorAttributeSyntaxContext context)
    {
        var classSymbol = context.TargetSymbol as INamedTypeSymbol;
        if (classSymbol is null) return null;

        var attributeData = context.Attributes.FirstOrDefault(a =>
            a.AttributeClass?.ToDisplayString() == ModuleTypeNames.GenerateModuleRegistryAttribute);

        string? customNamespace = null;
        if (attributeData?.NamedArguments.FirstOrDefault(a => a.Key == "Namespace").Value.Value is string ns)
        {
            customNamespace = ns;
        }

        // Get namespace, handling global namespace case
        var targetNamespace = customNamespace;
        if (string.IsNullOrEmpty(targetNamespace))
        {
            var containingNamespace = classSymbol.ContainingNamespace;
            if (containingNamespace != null && !containingNamespace.IsGlobalNamespace)
            {
                targetNamespace = containingNamespace.ToDisplayString();
            }
        }

        return new GenerationInfo(targetNamespace);
    }

    private static ImmutableArray<ModuleInfo> FindModuleImplementations(Compilation compilation)
    {
        var iModuleSymbol = compilation.GetTypeByMetadataName(ModuleTypeNames.IModule);
        if (iModuleSymbol is null)
        {
            // IModule not found - this means Shared.Abstractions is not referenced
            // Return empty array; modules won't be discovered but compilation will succeed
            return ImmutableArray<ModuleInfo>.Empty;
        }

        var modules = new List<ModuleInfo>();

        // Scan all referenced assemblies
        foreach (var reference in compilation.References)
        {
            if (compilation.GetAssemblyOrModuleSymbol(reference) is not IAssemblySymbol assemblySymbol)
                continue;

            // Skip system assemblies
            var assemblyName = assemblySymbol.Name;
            if (IsSystemAssembly(assemblyName))
                continue;

            FindModulesInNamespace(assemblySymbol.GlobalNamespace, iModuleSymbol, modules);
        }

        // Also scan the current compilation
        FindModulesInNamespace(compilation.Assembly.GlobalNamespace, iModuleSymbol, modules);

        return modules
            .OrderBy(m => m.TypeName)
            .ToImmutableArray();
    }

    private static void FindModulesInNamespace(
        INamespaceSymbol namespaceSymbol,
        INamedTypeSymbol iModuleSymbol,
        List<ModuleInfo> modules)
    {
        foreach (var type in namespaceSymbol.GetTypeMembers())
        {
            if (IsModuleImplementation(type, iModuleSymbol))
            {
                modules.Add(new ModuleInfo(type.ToDisplayString()));
            }
        }

        foreach (var nestedNamespace in namespaceSymbol.GetNamespaceMembers())
        {
            FindModulesInNamespace(nestedNamespace, iModuleSymbol, modules);
        }
    }

    private static bool IsModuleImplementation(INamedTypeSymbol type, INamedTypeSymbol iModuleSymbol)
    {
        // Must be a concrete class
        if (type.IsAbstract || type.TypeKind != TypeKind.Class)
            return false;

        // Must have parameterless constructor
        if (!type.Constructors.Any(c => c.Parameters.IsEmpty && c.DeclaredAccessibility == Accessibility.Public))
            return false;

        // Must implement IModule
        return type.AllInterfaces.Any(i => SymbolEqualityComparer.Default.Equals(i, iModuleSymbol));
    }

    private static bool IsSystemAssembly(string assemblyName)
    {
        return assemblyName.StartsWith("System", StringComparison.OrdinalIgnoreCase)
            || assemblyName.StartsWith("Microsoft", StringComparison.OrdinalIgnoreCase)
            || assemblyName.StartsWith("netstandard", StringComparison.OrdinalIgnoreCase)
            || assemblyName.StartsWith("mscorlib", StringComparison.OrdinalIgnoreCase)
            || assemblyName.StartsWith("Npgsql", StringComparison.OrdinalIgnoreCase)
            || assemblyName.StartsWith("Newtonsoft", StringComparison.OrdinalIgnoreCase)
            || assemblyName.StartsWith("Serilog", StringComparison.OrdinalIgnoreCase)
            || assemblyName.StartsWith("MediatR", StringComparison.OrdinalIgnoreCase)
            || assemblyName.StartsWith("FluentValidation", StringComparison.OrdinalIgnoreCase);
    }

    private static string GenerateModuleRegistry(string? targetNamespace, ImmutableArray<ModuleInfo> modules)
    {
        var sb = new StringBuilder();
        var indent = string.IsNullOrEmpty(targetNamespace) ? "" : "    ";
        
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using Shared.Abstractions.Modules;");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(targetNamespace))
        {
            sb.AppendLine($"namespace {targetNamespace}");
            sb.AppendLine("{");
        }

        sb.AppendLine($"{indent}/// <summary>");
        sb.AppendLine($"{indent}/// Auto-generated module registry. Contains all discovered IModule implementations.");
        sb.AppendLine($"{indent}/// </summary>");
        sb.AppendLine($"{indent}public static class ModuleRegistry");
        sb.AppendLine($"{indent}{{");
        sb.AppendLine($"{indent}    /// <summary>");
        sb.AppendLine($"{indent}    /// Gets all module instances.");
        sb.AppendLine($"{indent}    /// </summary>");
        sb.AppendLine($"{indent}    public static IModule[] GetModules() =>");
        sb.AppendLine($"{indent}    [");

        foreach (var module in modules)
        {
            sb.AppendLine($"{indent}        new {module.TypeName}(),");
        }

        sb.AppendLine($"{indent}    ];");
        sb.AppendLine();
        sb.AppendLine($"{indent}    /// <summary>");
        sb.AppendLine($"{indent}    /// Number of discovered modules: {modules.Length}");
        sb.AppendLine($"{indent}    /// </summary>");
        sb.AppendLine($"{indent}    public static int Count => {modules.Length};");
        sb.AppendLine($"{indent}}}");

        if (!string.IsNullOrEmpty(targetNamespace))
        {
            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    private readonly struct GenerationInfo
    {
        public GenerationInfo(string? ns) => Namespace = ns;
        public string? Namespace { get; }
    }

    private readonly struct ModuleInfo
    {
        public ModuleInfo(string typeName) => TypeName = typeName;
        public string TypeName { get; }
    }
}

